# Third-Party App Integration Guide

This document provides comprehensive instructions for integrating third-party applications with the Tournament App's QR code match submission system.

## Overview

The Tournament App supports external match result submission via QR codes. Tournament organizers can generate QR codes that encode match information, which third-party apps can scan to submit match results directly to the tournament system.

---

## Integration Flow

### 1. Basic Flow (No Audit Trail)

```
1. Tournament admin generates QR code in Tournament App
2. QR code contains match metadata (players, tournament ID, round, etc.)
3. Third-party app scans QR code
4. App parses JSON data from QR code
5. User enters match results in the app
6. App submits results to submitUrl endpoint (ONE TIME ONLY)
7. Tournament App processes and stores results
8. Match ID is permanently consumed - cannot resubmit
```

### 2. Flow with Audit Trail (Tournament Requires Identity)

```
1. User registers device with their name (one-time setup)
   → POST /api/submitter/register
   → Receives deviceToken (store securely on device)

2. Tournament admin generates QR code
3. Third-party app scans QR code
4. App checks requireSubmitterIdentity field
5. If true, app includes stored deviceToken in submission
6. App submits results with deviceToken
7. Tournament App validates token and records submitter identity
```

---

## QR Code Data Structure

### QRMatchData Interface

QR codes encode a JSON object with the following structure:

```typescript
{
  "matchId": "abc123xyz789",           // Unique match identifier (32 chars)
  "player1": "John Smith",             // First player name
  "player2": "Jane Doe",               // Second player name
  "tournamentId": 42,                  // Tournament database ID
  "round": 1,                          // Round number
  "baseUri": "https://example.com",    // Base URL for all API endpoints
  "submitUrl": "https://example.com/api/qr-match/submit",  // Submission endpoint
  "requireSubmitterIdentity": false    // Whether device token is required
}
```

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `matchId` | string | Unique identifier for this match (cryptographically random, 32 characters) |
| `player1` | string | Name of the first player/competitor |
| `player2` | string | Name of the second player/competitor |
| `tournamentId` | number | Internal tournament ID in the system |
| `round` | number | Round number in the tournament |
| `baseUri` | string | Base URL for the tournament system (e.g., `https://example.com`) - use this to construct other API endpoints |
| `submitUrl` | string | Full URL endpoint for submitting results (convenience field - same as `baseUri + "/api/qr-match/submit"`) |
| `requireSubmitterIdentity` | boolean | If `true`, deviceToken must be included in submission |

**⚠️ Important: Single-Use Match IDs**

Match IDs are **single-use only**. Once you successfully submit results for a match, that matchId is permanently removed from the system. Subsequent attempts to submit results using the same matchId will fail with a `404` error.

**Implications:**
- You cannot resubmit results for the same match using the same QR code
- If submission fails due to network issues, you can retry with the same matchId
- If results need correction after successful submission, a new QR code must be generated by the tournament admin
- Save match results locally before submission in case of failures

### Why baseUri is Included

The `baseUri` field simplifies third-party integration by providing a clean base URL for constructing API endpoints:

- **Device Registration**: Use `${baseUri}/api/submitter/register` for one-time device setup
- **Match Submission**: Use `${baseUri}/api/qr-match/submit` or the provided `submitUrl`
- **Future Extensions**: Any additional API endpoints can be easily constructed

**Example**:
```javascript
// Register device using baseUri
await fetch(`${qrData.baseUri}/api/submitter/register`, { /* ... */ });

// Submit match using provided submitUrl (recommended for forward compatibility)
await fetch(qrData.submitUrl, { /* ... */ });
```

---

## API Endpoints

### Base URI

The base URI is environment-specific and provided in the `baseUri` field of the QR code data.

- **Production**: `https://your-domain.com`
- **Development**: `http://localhost:3000`

### 1. Device Registration (Optional)

**Endpoint**: `POST /api/submitter/register`

**Purpose**: Register a device/user for audit trail tracking

**Request Headers**:
```
Content-Type: application/json
```

**Request Body**:
```json
{
  "name": "John Doe"
}
```

**Success Response** (HTTP 201):
```json
{
  "deviceToken": "abc123xyz789...",
  "name": "John Doe",
  "message": "Device registered successfully"
}
```

**Validation Rules**:
- `name` is required and cannot be empty
- `name` must be 255 characters or less
- Leading/trailing whitespace is automatically trimmed

**Error Responses**:
- `400 Bad Request`: Invalid request data or missing name
- `500 Internal Server Error`: Database error

**Important Notes**:
- Device tokens are **persistent** and should be stored securely on the device
- Registration is only required once per device
- The same device token can be used across multiple tournaments
- Tokens never expire unless manually deleted from the database

---

### 2. Submit Match Results

**Endpoint**: `POST /api/qr-match/submit`

**Purpose**: Submit match results for a QR-generated match

**Request Headers**:
```
Content-Type: application/json
```

**Request Body**:
```json
{
  "matchId": "abc123xyz789",
  "deviceToken": "optional_token_here",
  "player1_hits": 5,
  "player2_hits": 3,
  "winner": "John Smith"
}
```

**Field Descriptions**:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `matchId` | string | Yes | Match ID from QR code |
| `deviceToken` | string | Conditional | Required if `requireSubmitterIdentity` is `true` in QR data |
| `player1_hits` | number (integer) | Yes | Number of hits/points scored by player 1 (must be non-negative integer) |
| `player2_hits` | number (integer) | Yes | Number of hits/points scored by player 2 (must be non-negative integer) |
| `winner` | string | Yes | Name of the winning player (must match player1 or player2 exactly, case-sensitive) |

**Input Validation Rules**:
- `player1_hits` and `player2_hits` must be non-negative integers (0 or greater)
- `winner` must exactly match either `player1` or `player2` from the QR code data (case-sensitive)
- All required fields must be present and of the correct type
- Float values for hit counts will be rejected (e.g., 5.5 is invalid)
- Negative hit counts will be rejected (e.g., -1 is invalid)

**Success Response** (HTTP 200):
```json
{
  "success": true,
  "match": {
    "id": 123,
    "player1": "John Smith",
    "player2": "Jane Doe",
    "player1_hits": 5,
    "player2_hits": 3,
    "winner": "John Smith",
    "round": 1,
    "tournament_id": 42,
    "match": 1,
    "submitted_at": "2025-12-11T15:30:00.000Z"
  }
}
```

**Note**: The response includes `submitted_at` timestamp when audit trail is used, but does NOT include `submitted_by_token` for security reasons (device tokens are sensitive credentials).

**Error Responses**:

| Status Code | Message | Cause |
|-------------|---------|-------|
| `400` | "Error reading match result" | Invalid JSON in request body |
| `400` | "Invalid match result: ..." | Input validation failed (negative hits, invalid winner, wrong data types, etc.) |
| `400` | "Error adding/updating match: ..." | Failed to save match (database error) |
| `401` | "Device registration required for this tournament" | Tournament requires deviceToken but none provided |
| `401` | "Invalid device token" | Provided deviceToken doesn't exist in system |
| `404` | "Invalid or expired match ID" | matchId not found (already used or never existed) |
| `404` | "Tournament not found" | Tournament was deleted |

**Important Notes**:
- **Match IDs are single-use**: Once successfully submitted, the matchId is permanently removed from the system
- **Failed submissions can be retried**: If submission fails due to network/server errors, you can retry with the same matchId
- **No resubmission after success**: After a successful `200 OK` response, you cannot update results with the same matchId
- **Corrections require new QR code**: If match results need to be corrected after successful submission, the tournament admin must generate a new QR code
- If a match already exists in the database (from manual entry), the submission will update those results
- The `winner` field must exactly match either `player1` or `player2` from the QR code data (case-sensitive)
- Audit trail (submitted_by_token, submitted_at) is automatically recorded in the database if deviceToken is valid
- The response includes `submitted_at` timestamp but NOT `submitted_by_token` (device tokens are not exposed for security)

---

## CORS Configuration

The API supports Cross-Origin Resource Sharing (CORS) to allow web-based third-party apps to make requests.

### Preflight Requests

Both endpoints support OPTIONS requests for CORS preflight:

```http
OPTIONS /api/qr-match/submit HTTP/1.1
OPTIONS /api/submitter/register HTTP/1.1
```

**Response Headers**:
```
Access-Control-Allow-Origin: * (development) or configured domain (production)
Access-Control-Allow-Methods: POST, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
```

### Environment-Specific Configuration

- **Development**: Allows all origins (`*`) for testing
- **Production**: Restricted to single domain configured in `CORS_ALLOWED_ORIGIN` environment variable

**Note**: For production deployments, contact the tournament organizer to whitelist your app's domain.

---

## Implementation Examples

### Example 1: Basic JavaScript Integration (No Audit Trail)

```javascript
async function submitMatchResult(qrData, player1Hits, player2Hits, winner) {
  try {
    const response = await fetch(qrData.submitUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        matchId: qrData.matchId,
        player1_hits: player1Hits,
        player2_hits: player2Hits,
        winner: winner,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Submission failed: ${errorText}`);
    }

    const result = await response.json();
    console.log('Match submitted successfully:', result);
    return result;
  } catch (error) {
    console.error('Error submitting match:', error);
    throw error;
  }
}

// Usage
const qrCodeData = JSON.parse(scannedQRCodeString);
await submitMatchResult(qrCodeData, 5, 3, 'John Smith');
```

---

### Example 2: React Native with Audit Trail

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

const DEVICE_TOKEN_KEY = 'tournament_device_token';

// One-time device registration
async function registerDevice(name, baseUri) {
  try {
    const response = await fetch(`${baseUri}/api/submitter/register`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ name }),
    });

    if (!response.ok) {
      throw new Error('Registration failed');
    }

    const data = await response.json();

    // Store token securely on device
    await AsyncStorage.setItem(DEVICE_TOKEN_KEY, data.deviceToken);

    return data.deviceToken;
  } catch (error) {
    console.error('Device registration error:', error);
    throw error;
  }
}

// Submit match with device token
async function submitMatchWithIdentity(qrData, player1Hits, player2Hits, winner) {
  try {
    // Check if device token is required
    let deviceToken = null;
    if (qrData.requireSubmitterIdentity) {
      deviceToken = await AsyncStorage.getItem(DEVICE_TOKEN_KEY);

      if (!deviceToken) {
        throw new Error('Device not registered. Please register first.');
      }
    }

    const response = await fetch(qrData.submitUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        matchId: qrData.matchId,
        deviceToken: deviceToken,
        player1_hits: player1Hits,
        player2_hits: player2Hits,
        winner: winner,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Submission failed: ${errorText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error submitting match:', error);
    throw error;
  }
}

// Complete workflow
async function handleQRScan(qrCodeString, player1Hits, player2Hits, winner) {
  try {
    const qrData = JSON.parse(qrCodeString);

    // Check if device registration is required
    if (qrData.requireSubmitterIdentity) {
      const existingToken = await AsyncStorage.getItem(DEVICE_TOKEN_KEY);

      if (!existingToken) {
        // Prompt user for their name
        const userName = await promptForUserName();
        await registerDevice(userName, qrData.baseUri);
      }
    }

    // Submit match
    const result = await submitMatchWithIdentity(qrData, player1Hits, player2Hits, winner);
    console.log('Match submitted:', result);
  } catch (error) {
    console.error('Error:', error);
    alert(`Failed to submit match: ${error.message}`);
  }
}
```

---

### Example 3: Python Integration

```python
import json
import requests
from typing import Dict, Any

class TournamentAPIClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.device_token = None

    def register_device(self, name: str) -> str:
        """Register device and return token"""
        response = requests.post(
            f"{self.base_url}/api/submitter/register",
            json={"name": name},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()

        data = response.json()
        self.device_token = data["deviceToken"]
        return self.device_token

    def submit_match(
        self,
        qr_data: Dict[str, Any],
        player1_hits: int,
        player2_hits: int,
        winner: str
    ) -> Dict[str, Any]:
        """Submit match results"""
        payload = {
            "matchId": qr_data["matchId"],
            "player1_hits": player1_hits,
            "player2_hits": player2_hits,
            "winner": winner
        }

        # Include device token if required or available
        if qr_data.get("requireSubmitterIdentity") and self.device_token:
            payload["deviceToken"] = self.device_token
        elif self.device_token:
            payload["deviceToken"] = self.device_token

        response = requests.post(
            qr_data["submitUrl"],
            json=payload,
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()

        return response.json()

# Usage
qr_code_json = '{"matchId":"abc123",...}'  # Scanned from QR code
qr_data = json.loads(qr_code_json)

# Use baseUri from QR code data
client = TournamentAPIClient(base_url=qr_data["baseUri"])

# Register device if needed (one-time)
if qr_data.get("requireSubmitterIdentity"):
    client.register_device("John Doe")

# Submit match
result = client.submit_match(
    qr_data=qr_data,
    player1_hits=5,
    player2_hits=3,
    winner=qr_data["player1"]
)
print(f"Match submitted: {result}")
```

---

## Security Considerations

### 1. Device Token Storage

- Store device tokens **securely** on the device (e.g., Keychain on iOS, KeyStore on Android)
- Never log or display tokens to users
- Tokens are cryptographically random 32-character strings

### 2. Match ID Security

- Match IDs are single-use and expire after submission
- Each match ID is a cryptographically secure random string
- Invalid/expired match IDs return `404` errors

### 3. HTTPS Requirements

- **Always use HTTPS** in production
- The `submitUrl` field will use HTTPS in production environments
- Development environments may use HTTP (localhost only)

### 4. Input Validation

The API performs strict server-side validation on all match submissions. While client-side validation is recommended for better user experience, the server will reject invalid data with a `400` error.

**Required Validations (enforced by server)**:
- Hit counts (`player1_hits`, `player2_hits`) must be non-negative integers (0 or greater)
- No float/decimal values allowed for hit counts (e.g., 5.5 is rejected)
- Winner must exactly match either `player1` or `player2` from the QR code (case-sensitive)
- All required fields must be present and of correct type (string, number, etc.)

**Client-Side Validation Example**:
```javascript
function validateMatchData(qrData, player1Hits, player2Hits, winner) {
  const errors = [];

  // Validate hit counts are non-negative integers
  if (!Number.isInteger(player1Hits) || player1Hits < 0) {
    errors.push('Player 1 hits must be a non-negative integer');
  }
  
  if (!Number.isInteger(player2Hits) || player2Hits < 0) {
    errors.push('Player 2 hits must be a non-negative integer');
  }

  // Validate winner matches one of the players (case-sensitive)
  if (winner !== qrData.player1 && winner !== qrData.player2) {
    errors.push(`Winner must be "${qrData.player1}" or "${qrData.player2}"`);
  }

  return errors;
}
```

**Common Validation Errors**:
- `"Invalid player1_hits: cannot be negative"` - Negative hit count provided
- `"Invalid player1_hits: must be an integer"` - Float value provided (e.g., 5.5)
- `"Invalid winner: must be either..."` - Winner doesn't match player names or has wrong case

### 5. CORS Restrictions

- Production APIs restrict origins to configured domains
- Contact tournament administrators to whitelist your app domain
- Development environments allow all origins for testing

---

## Error Handling Best Practices

### 1. Network Errors

```javascript
async function submitWithRetry(qrData, results, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await submitMatchResult(qrData, results);
    } catch (error) {
      if (attempt === maxRetries) throw error;

      // Check if this is a 404 (match already submitted) - don't retry
      if (error.status === 404) {
        throw new Error('Match already submitted - matchId has been consumed');
      }

      // Exponential backoff for other errors
      await new Promise(resolve =>
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }
}
```

**Important**: Do NOT retry on `404` errors, as these indicate the match was already successfully submitted.

### 2. User-Friendly Error Messages

```javascript
function getErrorMessage(response, defaultMessage) {
  const errorMap = {
    400: 'Invalid match data. Please check your input.',
    401: 'Device registration required. Please register your device first.',
    404: 'Cannot submit - match already recorded or QR code invalid.',
    500: 'Server error. Please try again later.',
  };

  return errorMap[response.status] || defaultMessage;
}
```

**Note**: A `404` error usually means the match was already successfully submitted and the matchId consumed. The actual API response is `"Invalid or expired match ID"`.

**Example of resubmission attempt:**
```javascript
// First submission - succeeds
const response1 = await fetch(qrData.submitUrl, {
  method: 'POST',
  body: JSON.stringify({
    matchId: 'abc123xyz789',
    player1_hits: 5,
    player2_hits: 3,
    winner: 'John Smith'
  })
});
console.log(response1.status); // 200
console.log(await response1.text()); // {"success":true,"match":{...}}

// Second submission - fails
const response2 = await fetch(qrData.submitUrl, {
  method: 'POST',
  body: JSON.stringify({
    matchId: 'abc123xyz789', // Same matchId
    player1_hits: 5,
    player2_hits: 3,
    winner: 'John Smith'
  })
});
console.log(response2.status); // 404
console.log(await response2.text()); // "Invalid or expired match ID"
```

### 3. Validation Before Submission

```javascript
function validateMatchResult(qrData, player1Hits, player2Hits, winner) {
  const errors = [];

  if (winner !== qrData.player1 && winner !== qrData.player2) {
    errors.push('Winner must be one of the players');
  }

  if (player1Hits < 0 || player2Hits < 0) {
    errors.push('Hit counts cannot be negative');
  }

  if (!Number.isInteger(player1Hits) || !Number.isInteger(player2Hits)) {
    errors.push('Hit counts must be integers');
  }

  if (qrData.requireSubmitterIdentity && !deviceToken) {
    errors.push('Device registration required for this tournament');
  }

  return errors;
}
```

---

## Testing Your Integration

### 1. Development Environment Setup

1. Clone the tournament app repository
2. Run local development server: `npm run dev`
3. Access at `http://localhost:3000`

### 2. Test QR Code Generation

1. Log in as admin (create user with `role: "admin"`)
2. Create a test tournament
3. Generate QR code for a match
4. Scan with your app or copy JSON manually

### 3. Test Device Registration

```bash
curl -X POST http://localhost:3000/api/submitter/register \
  -H "Content-Type: application/json" \
  -d '{"name": "Test User"}'
```

Expected response:
```json
{
  "deviceToken": "...",
  "name": "Test User",
  "message": "Device registered successfully"
}
```

### 4. Test Match Submission

```bash
curl -X POST http://localhost:3000/api/qr-match/submit \
  -H "Content-Type: application/json" \
  -d '{
    "matchId": "your_match_id",
    "player1_hits": 5,
    "player2_hits": 3,
    "winner": "Player Name"
  }'
```

---

## FAQ

### Q: Can I reuse a match ID for multiple submissions?

**A**: No. Match IDs are **single-use only** and are permanently consumed upon successful submission. Once you receive a `200 OK` response, that match ID can never be used again. If you try to submit with the same match ID again, you'll receive a `404` error. This is by design to prevent duplicate submissions.

### Q: What happens if I update a match with different results?

**A**: If the match **has not been submitted via QR yet**, the submission will succeed and either create a new match or update an existing one (if manually entered by admin). If the match **has already been submitted via QR**, the match ID is gone and you'll get a `404` error. To correct results after a successful QR submission, the tournament admin must generate a new QR code for that match.

### Q: Is device registration permanent?

**A**: Yes. Once a device is registered, the token never expires unless manually deleted from the database. Users only need to register once.

### Q: Can I use the same device token across multiple tournaments?

**A**: Yes. Device tokens are user/device-specific, not tournament-specific. The same token can be used for any tournament that requires submitter identity.

### Q: What if I scan a QR code from a different tournament system?

**A**: The `baseUri` and `submitUrl` fields contain the full domain and endpoint URLs. Your app should dynamically use these URLs rather than hardcoding API endpoints, allowing it to work with any deployment of this tournament system.

### Q: Do I need to store the entire QR data or just the match ID?

**A**: You need to store the entire QR data object until submission, as you'll need the `baseUri` (for device registration), `submitUrl` (for submission), player names (for validation), and `requireSubmitterIdentity` flag.

### Q: What's the maximum length for player names?

**A**: Player names in the tournament system have a maximum length of 16 characters.

### Q: What if my submission fails? Can I retry?

**A**: Yes, but only if the submission truly failed (network timeout, 500 error, etc.). If you received a successful `200 OK` response, do NOT retry - the match has been recorded and the match ID consumed. Always check the HTTP status code before retrying. Implement exponential backoff for transient failures, but do not retry `404` errors as these indicate the match was already submitted.

### Q: How can I tell if my submission was successful?

**A**: A successful submission returns HTTP `200 OK` with a JSON response containing `{"success": true, "match": {...}}`. Save this response locally. If you get a `404` error on subsequent attempts, the match was already successfully submitted in a previous attempt.

### Q: Can I submit results for matches not generated via QR codes?

**A**: No. This API is specifically for QR-generated matches. Regular match entry must be done through the tournament app's web interface.

---

## Support and Contact

For technical support, bug reports, or feature requests:

- **GitHub Issues**: https://github.com/cy6erskunk/tournament-app/issues
- **Documentation**: See `README.md` in the repository

---

## Changelog

### Version 1.1 (Current)
- Added audit trail support with device registration
- Added `requireSubmitterIdentity` flag to QR codes
- Enhanced CORS configuration
- Improved error messages

### Version 1.0
- Initial QR match submission system
- Basic match result API
- CORS support for cross-origin requests
